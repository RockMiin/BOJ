## 1931. 회의실 배정

결국에는 도착시간 기준으로 정렬을 해서 순차적으로 탐색하는 방법을 이용한다.

이 때 처음부터 도착시간 기준으로 정렬만 한다면 시작 시간은 고려가 되지 않기 때문에 시작 시간 순서로 정렬을 해 준 다음에 도착시간 기준으로 정렬을 해 준 다음에 비교하는 것이 핵심이다.

```python
arr.sort()
arr.sort(key= lambda x: x[1])

-> arr.sort(key= lambda x: (x[1], x[0]))
```

처음 정렬은 리스트에서 첫번째 원소 기준으로 정렬을 실행하고, 두번째 정렬은 2번째 원소 기준으로 정렬을 실행시켜 준다.

++ 추가한 방식대로 한 번에 정렬을 할 수 있다.

```python
start, end= 0, 0
for i in range(n):
    x, y= arr[i][0], arr[i][1]
    if x>= end:
        start, end= x, y
        # print(start, end)
        cnt+=1
print(cnt)
```

이 후 순차적으로 탐색을 하면서 end값보다 크거나 같은 x값이 나오게 되면 개수를 세줌으로써 결과를 도출할 수 있다.

그리디 알고리즘으로 매 번 최선의 방법을 선택하여 해결할 수 있도록 정렬(?) 튜닝을 해주는 것이 키포인트인 것 같다. (처음에 시작 시간 기준으로 정렬만 하여 방법을 찾아서 애를 먹었다.)