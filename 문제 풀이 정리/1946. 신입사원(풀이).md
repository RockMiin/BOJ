## 1946. 신입사원

풀어보니 난이도는 막 어렵지 않은 문제였는데 문제를 이해하는데에 오래 걸렸던 문제이다. 

결국 그리디 문제는 매 순간 최선의 선택을 하도록 구현하는 것이 중요한 듯 -> 이번에는 이 순간의 반복문을 통과하면 cnt+=1로 되어 신입사원 추가해주는 부분으로 구현했음

input으로 받은 score는 등수이며 자신보다 서류 점수가 높은 모든 사람들의 면접 점수보다 면접 점수가 높아야 신입사원으로 될 수 있다는 것이 핵심이다.

N의 범위가 100,000이면서 1초 내에 통과를 하려면 시간 복잡도가 O(nlogn)이어야 통과가 가능하다.

이 문제는 2초이고 test case가 최대 20개까지 주어질 수 있으므로 nlogn보다 작은 시간복잡도로 알고리즘을 구성해야 한다. -> 정렬 알고리즘이 nlogn으로 제일 크고 cnt를 하는 것은 n으로 구현을 함

```python
def solution():
    t= int(input())
    for _ in range(t):
        n= int(input())
        score= []

        for i in range(n):
            score.append(list(map(int, input().split())))
        score.sort()

        cnt= 1
        tmp= 0
        for i in range(1, n):
            if score[tmp][1] > score[i][1]:
                tmp= i; cnt+=1
        print(cnt)
```

입력을 받아서 오름차순으로 정렬을 해준 뒤 탐색을 하는데 어차피 서류 점수 기준으로 정렬을 했기 때문에 반복문을 돌 때 이전의 사람들의 면접 점수는 고려할 필요가 없다(서류 점수가 자신보다 높기 때문) 이제 신입사원이 되려면 이전의 사람들보다 면접 점수가 높아야만 합격이 가능하므로 이전 사람들의 면접 최대 등수를 tmp에 저장해놓고 비교해서 크면 신입사원으로 합격, cnt를 추가시켜줘서 구현 